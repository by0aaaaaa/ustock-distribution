pragma solidity ^0.4.23;

import 'openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol';
import 'openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol';
import 'openzeppelin-solidity/contracts/ownership/Ownable.sol';


contract Ustock is StandardToken, Ownable {
    string public name = "UStock";
    string public symbol = "USK";
    uint256 public decimals = 18;
    uint256 public INITIAL_SUPPLY = 10000000000;                    // total supply
    uint256 public MINING_RESERVE = 10000000000 * 0.5;              // amount reserved for mining

    address public fundsWallet;                                     // funds reserve 50%

    mapping(address => string) public  keys;                        // map<eth address,  ultrain keys>
    bool public closed = false;                                     // whether close contract

    event Close();
    event Open();

    constructor(
        address _fundsWallet)
    public {
        fundsWallet = _fundsWallet;

        totalSupply_ = INITIAL_SUPPLY;
        balances[0xb1] = MINING_RESERVE;
        balances[fundsWallet] = INITIAL_SUPPLY - MINING_RESERVE;

        emit Transfer(0x0, 0xb1, MINING_RESERVE);
        emit Transfer(0x0, fundsWallet, INITIAL_SUPPLY - MINING_RESERVE);
    }

    // TODO 如果另onlyOwner 测试不过
    function transfer(address _to, uint _value) whenOpen public returns (bool) {
        return super.transfer(_to, _value);
    }

    // public key generated by ultrain
    function register(string key) whenOpen {
        assert(closed == false);
        assert(bytes(key).length <= 64);
        keys[msg.sender] = key;
    }

    function close() onlyOwner whenOpen public {
        closed = true;
        emit Close();
    }

    function open() onlyOwner whenClosed public {
        closed = false;
        emit Open();
    }

    modifier whenOpen() {
        require(!closed);
        _;
    }

    modifier whenClosed() {
        require(closed);
        _;
    }

}